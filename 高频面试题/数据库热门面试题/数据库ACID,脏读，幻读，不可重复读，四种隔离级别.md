# 数据库ACID,脏读，幻读，不可重复读，四种隔离级别

> 本文作者：[程序员牛肉](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)

- Atomicity:原子性，事务是原子的，一个操作不可分割，要么都失败，要么都成功，通过回滚日志来保证事务的原子性，修改前数据会先写入 undoLog，而 undoLog 是和脏页一起记录在 buffer 里的，等到合适时机才能进行刷盘。另外 undoLog 也是 InnoDB 引擎去实现 MVCC 的答案，通过 undolog 记录的每个不同时间戳的版本，当事务不可见时，就会去查询 undoLog，事务可见性算法是根据数据行 id 和 ReadView 快照， Read View 快照在 RC 隔离级别下是每次 Select 前都生成一个 Read View，因此每次读取到最新的数据行。而 RR 隔离级别下是事务开始后第一次 Select 执行前生成 Read View ，读取的就是事务开启时的数据行版本。
- Consistency: 一致性，AB互相转账，AB总额不变。一致性是目的，其他是手段去保证一致性。
- Isolation: 隔离性, 多个事务并发访问，事务之间是隔离的，一个事务不应该影响其他事务运行效果。
- Durability: 持久性,在事务完成提交后，该事务对数据库所作的更改是持久的，隔离性通过 RedoLog 重做日志去保证，因为 MySQL 数据修改不是直接刷盘的，而是通过一个 Buffer Pool 缓冲池，数据库读取数据的单位是数据页，先会去查询缓冲池是否有该数据页，如果有的话，直接去缓冲池将数据页的数据更新，然后将这个修改记录到 RedoLog Buffer 重做日志缓存中，接着刷盘到 redoLog 文件，刷盘策略有三种，默认是1 每次事务提交都进行刷盘，因此事务提交成功后 RedoLog 就一定在磁盘里，会先于数据持久化到磁盘。设置为0时候，每次事务提交不进行刷盘，但如果 MySQL 实例宕机，就可能丢失最近 1秒内的事务。设置为 2 时，每次事务提交将 redolog Buffer 重做日志缓存写入文件系统缓存，因此 MySQL 实例挂了不会丢失数据，但主机宕机的话会有 1秒数据的丢失。
- 读未提交（Read Uncommitted）最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- 读已提交（Read Committed）允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
- 可重复读（Repeatable Read）对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。select（快照读)不会产生幻读，但对于update(当前读)会产生幻读。
- 可串行化(Serializable) 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
- 脏读: 当一个事务读取另一个事务尚未提交的修改（update,insert,delete),产生脏读。
- 不可重复读: 同一查询在同一事务中多次进行，但由于其他事务已经提交的修改或删除，造成返回不同的结果集。
- 幻读：同一查询在同一事务中多次进行，由于其他事务已经提交的插入操作，每次返回不同的结果集。