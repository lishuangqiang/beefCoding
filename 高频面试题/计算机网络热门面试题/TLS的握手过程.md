# TLS的握手过程

> 本文作者：[程序员牛肉](https://github.com/luoye6)
>
> 本站地址：[https://xbt.xiaobaitiao.top](https://xbt.xiaobaitiao.top)

![](https://pic.yupi.icu/5563/202506241921993.png)

https的信息加密是混合加密，也就是**对称加密**与**非对称加密**。双方通通信开始前要协商密钥，密钥协商时采用的是[非对称加密](https://so.csdn.net/so/search?q=非对称加密&spm=1001.2101.3001.7020)，进行通信时使用的对称加密。

在密钥协商阶段主要用到以下几种算法：

- RSA算法
- DH算法
- ECDHE算法

**TLS第一次握手**

clientHello阶段，客户端向服务器发送请求，发送SSL/TLS版本，发送客户端支持的密码套件列表，然后会产生一个随机数（Client Random），发送给服务器，这是生成对称密钥的材料。



**第一次握手客户端做的事：**

客户端clientHello，客户端发送请求

确定SSL/TLS版本

客户端生成的随机数，用于生成会话密钥（Client Random）

客户端支持的密码套件列表，如RSA算法**TLS第二次握手**

服务器会确定自己所支持的SSL/TLS版本，如果不支持，则直接关闭此次连接。在客户端发送来的密码套件中选择一套。生成一个随机数（Server Random）

serverHello阶段，服务器响应客户端的请求，发送SSL/TLS版本，发送服务器选择的密码套件，发送随机数![](https://pic.yupi.icu/5563/202506241921409.png)

密码套件：密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法

WITH单词前面只有一个单词RSA

密钥交换算法和签名算法都是RSA

加密对称算法采用的是AES算法，密钥长度为128位，分组模式为GCM

摘要算法为SHA256，用于消息认证和产生随机数

发送数字证书

最后会发一个Server Hello Done的信息



**第二次握手服务器做的事：**

服务器接收到客户端请求，进行响应

确定SSL/TLS版本，如果不支持，直接关闭

服务器生成的随机数，后面用于生成会话密钥（Server Random）

确定服务器支持的密码套件列表，如RSA加密算法

发送数字证书

客户端拿到服务器的响应后，会去验证证书的证实有效性

数字证书包含

公钥

持有者信息

有效时间

证书认证机构（CA）的信息

其他信息

数字证书的签发流程

CA会把一些基本信息例如持有者、用途、有效信息等打包，然后运用Hash算法得到一个Hash值

CA会使用自己的私钥将这个Hash值加密，生成一个Certificate Signature（证书签名），CA对证书进行了签名

最后将签名加到证书文件，形成数字证书

客户端验证证书的流程

客户端使用同样的Hash算法，得到该证书的Hash值H1

浏览器使用CA的公钥，解密Certificate Signature中的内容，得到Hash值H2

如果H1等于H2，则证明可信



**TLS的第三次握手**

证书有效，客户端生成一个随机数（pre-master），用服务器的RSA公钥加密，然后通过Change Cipher Key Exchange消息发给服务器

服务器收到后，用私钥解密收到pre-master

到此阶段，客户端和服务器共享了三个数，Client Random、Server Random、pre-master，双方根据这三个数生成密钥

生成密钥后客户端再发一个Change Cipher Spec告诉服务器开始使用加密通话

最后在发送一个Encrypted HandShare Message消息，向服务器发送握手摘要，再加密一下，让服务器验证

第三次握手客户端做的事：

向服务器进行响应

发送一个随机数（密钥），该随机数会被公钥加密（pre-master）

加密算法改变的通知，表示之后的会话都将用会话密钥进行加密（Change Cipher Key Exchange）

客户端响应结束通知，握手数据的摘要（Encrypted HandShare Message）



**TLS的第四次握手**

服务器也是相同操作，发送Change Ciper Spec和Encrypted HandShare Message

服务器进行响应

加密算法改变通知，表示之后的信息会用加密的密钥进行加密（Change Ciper Spec）

服务器响应结束通知，握手数据的摘要（Encrypted HandShare Message）

RSA算法的缺陷

RSA算法最大的问题就是不支持前向保密，服务器的私钥一旦泄露，被第三方截获的TLS密文都会被破解

所以才有了DH算法

DH算法

客户端和服务器都各自产生一个随机数，生成一个私钥，然后根据公开的DH算法，算出自己的公钥，再把这个公钥通过TLS互换，这要有了自己的私钥和对方的公钥，就可以解密报文。

即时公钥被截取了，在不知道私钥的情况下也无法计算出密钥。

但是DH算法存在计算效率的问题，所以出现了ECDHE密钥协商算法

ECDHE算法

根据私钥的生成算法，有两种模式

DH算法（服务器的私钥是不变的）缺点是时间长了服务器的私钥有被破解的可能

DHE算法（目前常用）E（ephemeral）的意思就是临时性的

双方的私钥在每次密钥交换通信时都是临时生成的。但是这种算法的性能不佳，所以出现了ECDHE算法

ECDHE算法

在DHE算法的基础上，利用了ECC椭圆曲线的特性，可以优化计算公钥和最终会话密钥的计算量

ECDHE算法流程（实质就是通过椭圆曲线特性计算公钥）

双方事先确定好使用什么椭圆曲线，和曲线上的基点G，两个参数都是公开的

双方各自随机生成私钥d，将G乘以私钥d得到公钥Q（Q=Gd），客户端的公私钥为d1和Q1，服务器的公私钥为d2和Q2

双方交换公钥，客户端计算d1Q2，服务器计算d2Q1，由乘法交换律和结合律得d2Q1 = d2d1G = d1d2G = d1Q2,双方的坐标都是一样的，实现了共享密钥

此过程双方的私钥都是随机、临时生成的，不公开的。